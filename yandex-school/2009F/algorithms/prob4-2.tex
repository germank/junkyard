\documentclass[a4paper, 12pt, onepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{cmap}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{pdfpages}

\usepackage[pdftex, unicode, pdfstartview=FitH, colorlinks, linkcolor=blue, citecolor=blue, urlcolor=blue]{hyperref}
\usepackage{url}
\def\UrlFont{\rmfamily}

\usepackage{setspace}
\onehalfspacing

\usepackage{cyrtimes}
\renewcommand\ttdefault{cmtt}

\frenchspacing
\sloppy
\selectlanguage{russian}

\begin{document}

\subsection*{Вариант: №2 (число деревьев)}

Предположим, что ключи $a_1, \ldots, a_n$ уже отсортированы.

Будем использовать динамическое программирование для решения подзадач
следующего вида: подсчитать число деревьев, построенных на мультимножестве ключей
c $i$-го включительно по $j$-й, не включая его (то есть $a_i, a_{i+1}, \ldots, a_{j-1}$).

В качестве базового случая будем рассматривать случай, когда $i=j$.
Будем считать, что можно построить ровно одно дерево -- пустое.

Если $i < j$, то дерево не пустое. У него должен быть корень, ключ которого
будем перебирать из $a_i, \ldots, a_j$. Если ключи повторяются, то
в качестве корня нужно попробовать любой из них только один раз,
иначе мы будем считать одинаковые деревья по нескольку раз.
Для определённости, пусть это будет ключ $a_k$ с наименьшим индексом $k$ среди всех ключей
с равными ему значениями. Тогда ключи $a_i, \ldots, a_{k-1}$ будут строго
меньше его и должны быть отнесены к левому поддереву. Число таких
поддеревьев равно $f(i, k)$ по индукции.
Правое поддерево содержать все остальные ключи, за исключением
самого $a_k$, а это будет мультимножество из ключей $a_{k+1}, \ldots, a_{j-1}$.
Число таких поддеревьев -- $f(k+1, j)$.

Если левое поддерево можно выбрать $f(i,k)$ способами, а правое -- $f(k+1, j)$
способами, то левое и правое поддеревья можно выбрать $f(i,k) \cdot f(k+1, j)$
способами. Просуммировав это по всем возможным ключам в корне, избегая повторяющихся ключей,
и получим $f(i,j)$.

\bigskip

Сложность: $O(n^3)$ = $\Theta(n^2)$ состояний $\times\ O(n)$ времени на обработку каждого.
(На самом деле сложность даже $\Theta(n^3)$, так в решении есть три цикла, перебирающих, как минимум, все ${n \choose 3}$
троек индексов ключей)

Сложность по памяти: $\Theta(n^2)$.

\end{document}
