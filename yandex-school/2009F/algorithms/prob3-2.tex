\documentclass[a4paper, 12pt, onepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{cmap}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{pdfpages}

\usepackage[pdftex, unicode, pdfstartview=FitH, colorlinks, linkcolor=blue, citecolor=blue, urlcolor=blue]{hyperref}
\usepackage{url}
\def\UrlFont{\rmfamily}

\usepackage{setspace}
\onehalfspacing

\usepackage{cyrtimes}
\renewcommand\ttdefault{cmtt}

\frenchspacing
\sloppy
\selectlanguage{russian}

\begin{document}

Вариант: №3 (Али-Баба)

Пусть монеты пронумерованы слева направо числами от $0$ до $N-1$, и $x_i$ -- позиция $i$-й монеты.

Оптимальный маршрут будет выглядеть следующим образом.
Он обязательно будет стартовать с позиции какой-либо монеты (иначе тратится лишнее время, чтобы дойди до первой монеты).
Каждую монету, естественно, надо подбирать сразу, как только была посещена точка, где она лежит.
В любой момент времени множество посещённых точек -- это какой-то отрезок прямой, и значит
подобраны будут ровно все лежащие в нём монеты, то есть монеты с номерами $i, i+1, \ldots, j$ для некоторых индексов $i, j$.
В момент, когда подбирается очередная монета, она должна лежать на конце этого интервала.
После того как она подобрана, оптимально либо продолжать движение в том же направлении к следующей монете,
либо развернуться, пройти уже посещённые монеты, и прийти к первой непосещённой монете на другом конце. 

Будем использовать динамическое программирование для решения подзадач такого вида: за какое минимальное
время, можно посетить монеты с $i$-й по $j$-ю (и только их), соблюдая все дедлайны для этих точек,
и в конце оказаться в одном из двух заданных конов этого интервала.
Это может быть $+\infty$, если в дедлайны нельзя вписаться.
Обозначим за $f(i, j, 0)$ это время, если в конце мы хотим оказаться в точке $x_i$, а за $f(i, j, 1)$ -- если в $x_j$. 

Базовый случай: $f(i, i, *) = 0$ -- так как можно сразу стартовать из любой точки.

Пусть теперь $j - i > 0$. Рассмотрим как можно вычислить $f(i, j, 0)$.
В точку $x_i$ можно попасть только справа, после того как были подняты монеты с номерами $i+1, \ldots, j$.
После поднятия этих монет Али-Баба может оказаться либо в точке $x_{i+1}$, либо в $x_j$.
Для каждого из этих случаев вычислим время, за которое Али-Баба может там оказаться
($f(i+1, j, 0)$ и $f(i+1, j, 1)$, соответственно), прибавим к нему время,
за которое он от этой точки доберётся до $x_i$, и возьмем из полученных двух чисел минимум.
Если он не превышает дедлайн для $i$-й монеты, то это и будет значением $f(i, j, 0)$.
А иначе $f(i,j,0)=\infty$.

Для $f(i,j,1)$ всё симметрично.

Ответом будем $\min_{k \in \{0, 1\}} f(0, N-1, k)$.

\bigskip

Число подзадач -- $\Theta(n^2)$, на решение каждой тратится $\Theta(1)$ времени,
на все остальное (чтение, сортировку) тратится ещё $O(n \log n)$ времени,
поэтому общая сложность по памяти и времени -- $\Theta(n^2)$.

Сложность по памяти можно уменьшить до $\Theta(n)$.

\end{document}
